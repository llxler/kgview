<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        background-color: #071130;
        ;
    }

    /* .link {
        fill: none;
        stroke: #666;
        stroke-width: 1.5px;
    }

    #licensing {
        fill: green;
    }

    .link.licensing {
        stroke: green;
    }

    .link.resolved {
        stroke-dasharray: 0, 2 1;
    }

    circle {
        fill: #390e88;
        stroke: #333;
        stroke-width: 1.5px;
    }

    text {
        font: 12px Microsoft YaHei;
        pointer-events: none;
        text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
    }

    .linetext {
        font-size: 12px Microsoft YaHei;
    } */

    .search {
        position: absolute;
        left: 50%;
        top: 150px;
        width: 640px;
        transform: translate(-50%);
        text-align: center;
        font-size: 18px;
        line-height: 46px;
        border-radius: 100px;
        border: none;
        outline: none;
    }
</style>

<input type="text" id="myInput" class="search" onkeydown="submitForm(event);">
<div id="graphContainer" style="width: 100%; height: 100vh; color: #071130"></div>

<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script>

        var links =
            [];
        function submitForm(e) {
            var evt = window.event || e;
            if (evt.keyCode == 13) {
                var input = document.getElementById("myInput").value;
                fetch('http://127.0.0.1:12345/kgview', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ entity: input })
                })
                    .then(response => response.json())
                    .then(data => {
                        links = eval(data); // Assign the fetched data to the links variable
                        console.log(links); // Print the links to check if the data is correct
                        update1();
                    })
                    .catch(error => {
                        console.error('Error:', error); // Handle any errors
                    });
            }
        }

        function update1() {
            var nodes = {};

            links.forEach(function (link) {
                link.source = nodes[link.source] || (nodes[link.source] = { name: link.source });
                link.target = nodes[link.target] || (nodes[link.target] = { name: link.target });
            });

            var width = window.innerWidth, height = window.innerHeight;

            var force = d3.layout.force()
                .nodes(d3.values(nodes))
                .links(links)
                .size([width, height])
                .linkDistance(250)
                .charge(-1500)
                .on("tick", tick)
                .start();

            var svg = d3.select("#graphContainer").append("svg")
                .attr("width", width)
                .attr("height", height);

            var marker =
                svg.append("marker")
                    .attr("id", "resolved")
                    .attr("markerUnits", "userSpaceOnUse")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 32)
                    .attr("refY", -1)
                    .attr("markerWidth", 12)
                    .attr("markerHeight", 12)
                    .attr("orient", "auto")
                    .attr("stroke-width", 1)
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr('fill', '#FFFFFF');

            var edges_line = svg.selectAll(".edgepath")
                .data(force.links())
                .enter()
                .append("path")
                .attr({
                    'd': function (d) { return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y },
                    'class': 'edgepath',
                    'id': function (d, i) { return 'edgepath' + i; }
                })
                .style("stroke", function (d) {
                    var lineColor;
                    lineColor = "#D5D2D5";
                    return lineColor;
                })
                .style("pointer-events", "none")
                .style("stroke-width", 0.3)
                .attr("marker-end", "url(#resolved)");

            var edges_text = svg.append("g").selectAll(".edgelabel")
                .data(force.links())
                .enter()
                .append("text")
                .style("pointer-events", "none")
                .attr({
                    'class': 'edgelabel',
                    'id': function (d, i) { return 'edgepath' + i; },
                    'dx': 80,
                    'dy': 0,
                    'fill': '#7F8188' // Set the text color to white
                });

            edges_text.append('textPath')
                .attr('xlink:href', function (d, i) { return '#edgepath' + i })
                .style("pointer-events", "none")
                .text(function (d) { return d.rela; });

            var colorArray = [
                "#FF5733", // 橙色
                "#44CC77", // 淡绿色
                "#4466FF", // 淡蓝色
                "#CC55FF", // 紫色
                "#FF5544", // 红色
                "#44FFFF", // 青色
                "#FFBB33", // 明黄色
                "#CC55CC", // 粉紫色
                "#55AAFF", // 天蓝色
                "#55FFCC", // 青绿色
                "#FF8844", // 橘黄色
                "#FF55AA", // 粉红色
                "#AAFF55", // 鲜黄绿色
                "#4455FF", // 蓝色
                "#FFFF55", // 淡黄色
                "#FF5577", // 鲜红色
                "#55FF99", // 青绿色
                "#9955FF", // 紫罗兰色
                "#77FF55", // 淡绿色
                "#FF5588"  // 淡紫色
            ];
            var circle = svg.append("g").selectAll("circle")
                .data(force.nodes())
                .enter().append("circle")
                .style("fill", function (node, index) {
                    var link = links[node.index];
                    return colorArray[index % colorArray.length];
                })
                .attr("r", 16)
                // .on("click", function (node) {
                //     edges_line.style("stroke-width", function (line) {
                //         console.log(line);
                //         if (line.source.name == node.name || line.target.name == node.name) {
                //             return 4;
                //         } else {
                //             return 0.5;
                //         }
                //     });
                // })
                .call(force.drag);

            var text = svg.append("g").selectAll("text")
                .data(force.nodes())
                .enter()
                .append("text")
                .attr("dy", "-1.5em")
                .attr("text-anchor", "middle")
                .style("white-space", "nowrap")

                .style('fill', function (node) {
                    var color;
                    var link = links[node.index];
                    color = "#FFFFFF";
                    return color;
                }).attr('x', function (d) {
                    var re_en = /[a-zA-Z]+/g;
                    if (d.name.match(re_en)) {
                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', 2)
                            .text(function () { return d.name; });
                    }

                    else if (d.name.length <= 4) {
                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', 2)
                            .text(function () { return d.name; });
                    } else {
                        var top = d.name.substring(0, 4);
                        var bot = d.name.substring(4, d.name.length);

                        d3.select(this).text(function () { return ''; });

                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', -7)
                            .text(function () { return top; });

                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', 10)
                            .text(function () { return bot; });
                    }
                });

            function tick() {
                circle.attr("transform", transform1);
                text.attr("transform", transform2);

                edges_line.attr('d', function (d) {
                    var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
                    return path;
                });

                edges_text.attr('transform', function (d, i) {
                    if (d.target.x < d.source.x) {
                        bbox = this.getBBox();
                        rx = bbox.x + bbox.width / 2;
                        ry = bbox.y + bbox.height / 2;
                        return 'rotate(180 ' + rx + ' ' + ry + ')';
                    }
                    else {
                        return 'rotate(0)';
                    }
                });
            }

            function linkArc(d) {
                return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y
            }

            function transform1(d) {
                return "translate(" + d.x + "," + d.y + ")";
            }
            function transform2(d) {
                return "translate(" + (d.x) + "," + d.y + ")";
            }
        }

    </script>
</body>